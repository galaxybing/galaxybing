#### es6 规定
1. ES6第一次明确规定，所有 ECMAScript 的实现，都必须部署"尾调用优化"；但是在Babel 6中暂时性移除：由于其复杂性与全局支持尾调用产生的冲突，只有在明确自己指向尾部的递归方法时才能支持。由于其他一些bug被移除并将得到从新实现。
2. ES6的尾调用优化只在严格模式下开启，正常模式是无效的。
```
这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈:
    arguments：返回调用时函数的参数。
    func.caller：返回调用当前函数的那个函数。
尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。
```
3. 尾递归，[在浏览器中没有内置实现](https://jsfiddle.net/galaxybing/o1kzz0tt/1/)，但`尾调用`实现了？？
    - [尾递归优化的实现，其思路是递归执行转为循环执行](https://jsfiddle.net/galaxybing/o1kzz0tt/)
4. 将多参数的函数转换成单参数的形式：
    - currying
    - non-simple parameter, “非简单参数”， 采用ES6的函数默认值
#### [原理运作](http://www.ruanyifeng.com/blog/2015/04/tail-call.html)
- "尾调用优化"（Tail call optimization）,即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。
